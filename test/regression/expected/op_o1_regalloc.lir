add:  # 0 params, 0 stack bytes
.add_entry:
        movl    $3, %eax
        ret

sub:  # 0 params, 0 stack bytes
.sub_entry:
        movl    $9, %eax
        ret

mul:  # 0 params, 0 stack bytes
.mul_entry:
        movl    $12, %eax
        ret

div:  # 0 params, 0 stack bytes
.div_entry:
        movl    $4, %eax
        ret

lshift:  # 0 params, 0 stack bytes
.lshift_entry:
        movl    $16, %eax
        ret

rshift:  # 0 params, 0 stack bytes
.rshift_entry:
        movl    $2, %eax
        ret

bit_and:  # 0 params, 0 stack bytes
.bit_and_entry:
        movl    $4, %eax
        ret

bit_or:  # 0 params, 0 stack bytes
.bit_or_entry:
        movl    $15, %eax
        ret

bit_xor:  # 0 params, 0 stack bytes
.bit_xor_entry:
        movl    $11, %eax
        ret

unary_plus:  # 0 params, 0 stack bytes
.unary_plus_entry:
        movl    $42, %eax
        ret

unary_minus:  # 0 params, 0 stack bytes
.unary_minus_entry:
        movl    $18446744073709551574, %eax
        ret

unary_bitwise_not:  # 0 params, 0 stack bytes
.unary_bitwise_not_entry:
        movl    $18446744073709551573, %eax
        ret

add_equals:  # 0 params, 0 stack bytes
.add_equals_entry:
        movl    $3, %eax
        ret

sub_equals:  # 0 params, 0 stack bytes
.sub_equals_entry:
        movl    $8, %eax
        ret

mul_equals:  # 0 params, 0 stack bytes
.mul_equals_entry:
        movl    $12, %eax
        ret

div_equals:  # 0 params, 0 stack bytes
.div_equals_entry:
        movl    $4, %eax
        ret

lshift_equals:  # 0 params, 0 stack bytes
.lshift_equals_entry:
        movl    $16, %eax
        ret

rshift_equals:  # 0 params, 0 stack bytes
.rshift_equals_entry:
        movl    $2, %eax
        ret

bit_and_equals:  # 0 params, 0 stack bytes
.bit_and_equals_entry:
        movl    $4, %eax
        ret

bit_or_equals:  # 0 params, 0 stack bytes
.bit_or_equals_entry:
        movl    $15, %eax
        ret

bit_xor_equals:  # 0 params, 0 stack bytes
.bit_xor_equals_entry:
        movl    $11, %eax
        ret