add:  # 0 params, 0 stack bytes
.Ladd_entry:
        movl    $3, %eax
        ret

sub:  # 0 params, 0 stack bytes
.Lsub_entry:
        movl    $9, %eax
        ret

mul:  # 0 params, 0 stack bytes
.Lmul_entry:
        movl    $12, %eax
        ret

div:  # 0 params, 0 stack bytes
.Ldiv_entry:
        movl    $4, %eax
        ret

lshift:  # 0 params, 0 stack bytes
.Llshift_entry:
        movl    $16, %eax
        ret

rshift:  # 0 params, 0 stack bytes
.Lrshift_entry:
        movl    $2, %eax
        ret

bit_and:  # 0 params, 0 stack bytes
.Lbit_and_entry:
        movl    $4, %eax
        ret

bit_or:  # 0 params, 0 stack bytes
.Lbit_or_entry:
        movl    $15, %eax
        ret

bit_xor:  # 0 params, 0 stack bytes
.Lbit_xor_entry:
        movl    $11, %eax
        ret

unary_plus:  # 0 params, 0 stack bytes
.Lunary_plus_entry:
        movl    $42, %eax
        ret

unary_minus:  # 0 params, 0 stack bytes
.Lunary_minus_entry:
        movl    $18446744073709551574, %eax
        ret

unary_bitwise_not:  # 0 params, 0 stack bytes
.Lunary_bitwise_not_entry:
        movl    $18446744073709551573, %eax
        ret

add_equals:  # 0 params, 0 stack bytes
.Ladd_equals_entry:
        movl    $3, %eax
        ret

sub_equals:  # 0 params, 0 stack bytes
.Lsub_equals_entry:
        movl    $8, %eax
        ret

mul_equals:  # 0 params, 0 stack bytes
.Lmul_equals_entry:
        movl    $12, %eax
        ret

div_equals:  # 0 params, 0 stack bytes
.Ldiv_equals_entry:
        movl    $4, %eax
        ret

lshift_equals:  # 0 params, 0 stack bytes
.Llshift_equals_entry:
        movl    $16, %eax
        ret

rshift_equals:  # 0 params, 0 stack bytes
.Lrshift_equals_entry:
        movl    $2, %eax
        ret

bit_and_equals:  # 0 params, 0 stack bytes
.Lbit_and_equals_entry:
        movl    $4, %eax
        ret

bit_or_equals:  # 0 params, 0 stack bytes
.Lbit_or_equals_entry:
        movl    $15, %eax
        ret

bit_xor_equals:  # 0 params, 0 stack bytes
.Lbit_xor_equals_entry:
        movl    $11, %eax
        ret